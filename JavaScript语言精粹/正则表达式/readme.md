- 举个栗子：
  匹配URL的正则表达式：
  ```
  var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
  var url = "http://www.ora.com:80/goodparts?q#fragment";
  ```
  - ^ 
    表示匹配字符串的开始
  - (?:([A-Za-z]+):)? 
    - 匹配一个协议名，仅当它后面跟随一个:(冒号)的时候才匹配，(?:...)表示一个非捕获型分组
    - 后缀 ? 表示这个分组是可选的
    - (...) 表示一个捕获型分组，会赋值匹配到的文本放入一个数组arr中，第一个捕获分组放在arr[1]，以此类推
    - [...] 表示一个字符类 
    - 连字符(-) 表示范围匹配 
    - +表示匹配一次或多次
    - 组后面跟着字符 : 表示按照字面进行匹配
  - (\/{0,3})
    - \/表示应该匹配 / ，\ 是对它的转义
    - {0,3} 表示 / 会被匹配0次，或者1-3次
  - ([0-9.\-A-Za-z]+)
    - 匹配一个主机名，由一个或多个数字、字母，以及 . 或 - 字符组成
    - -会被转义为 \- 以防止与表示范围的连字符相混淆
  - (?::(\d+))?
    - 由一个前置 : 加上一个或多个数字而组成的序列
    - \d 表示一个数字字符
  - (:\/([^?#]*))?
    - [^?#] 表示除 ?# 之外的所有字符
    - *表示匹配0次或多次
  - (?:#(.*))?
    - . 会匹配除行结束符以外的所有字符
  - $ 
    表示匹配字符串的结束

- 要注意的地方：
  正则表达式中的空格一定不能乱用！否则可能造成查找的失效

- 正则表达式标识
  - g 全局的(匹配多次；不同的方法对g标识的处理各不相同)
  - i 忽略字符大小写
  - m 多行(^和$能匹配结束符)

- 构成正则表达式的元素
  1. 正则表达式分支
     into.match(/in|int/) 会匹配in，但不会匹配int，因为in已经被成功匹配
  2. 正则表达式序列
     每个因子能选择是否跟随一个量词，决定这个因子被允许出现的次数(默认匹配一次)
  3. 正则表达式因子
     可以是一个字符、一个由圆括号包围的组、一个字符类，或者是一个转义序列
     除了控制字符和特殊字符以外，所有的字符都会被按照字面处理:
       \ / [ ] () { } ? + * | . ^ $
     匹配上述字符时需要使用 \ 转义 notice: \ 前缀不能式字母或数字字面化
     一个未被转义的 . 会匹配除结束符以外的任何字符
  4. 正则表达式转义
     - \f 换页符 \n 换行符 \r 回车符 \t 制表(tab)符 
     - \d 等同于[0-9]，匹配一个数字
     - \D 与\d相反，等同于[^0-9]，匹配非数字
     - \w 等同于[0-9A-Za-z_]，匹配数字、字母和下划线(_)
     - \W 与\w相反，等同于[^0-9A-Za-z_]
     - \1 指向分组1所捕获到的文本的一个引用，所以它能被再次匹配，\2指向分组2的引用，以此类推
       举个栗子：
       var doubled-words = /([A-Za-z\u00C0-\u1FFF\u2800-\uFFFD]+)\s+\1/gi 寻找重复的单词，该单词后面跟着一个或多个空白，然后再跟着与它相同的单词
  5. 正则表达式分组
     - 捕获型
       一个被包围在圆括号中的正则表达式分支
     - 非捕获型
       有一个 (?: 前缀
       不会干扰捕获型分组的编号
     - 向前正向匹配
       有一个 (?= 前缀
       类似于非捕获型分组，在这个分组匹配完之后，文本会倒回它开始的地方，实际上并不匹配任何东西
     - 向前负向匹配
       有一个 (?! 前缀
       类似于向前正向匹配型分组，但只有当它匹配失败时它才会继续向前进行匹配
  6. 正则表达式字符集
     举个栗子：
     匹配一个元音字母：(?:a|e|i|o|u) -> [aeiou]
  7. 正则表达式转义
  8. 正则表达式量词
     包围在一堆花括号中的一个数字表示这个因子应该被匹配的次数
     /www/ 和 /w(3)/ 一样
     {3,6} 会匹配3、4、5或6次 {3,} 会匹配3次或多次
     ？等同于{0，1}
     *等同于{0,}
     +等同于{1,}
     