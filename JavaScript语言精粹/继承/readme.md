- 伪类
  插入一个多余的中间层，通过构造器函数产生对象
  - 当一个函数对象被创建的时候，Function构造器产生的函数对象会运行类似这样的代码:
    this.prototype = {constructor: this};

- 函数化 
  继承模式没法保护隐私，对象的所有属性都是可见的
  得到私有变量和私有函数的方法：
  1. 创建一个对象 构造一个生成对象的函数(小写字母开头，因为它不需要使用new创建对象)
  2. 定义私有实例变量和方法
  3. 给这个新对象扩充方法，这些方法拥有特权去访问参数
  4. 返回那个对象

  var constructor = function(spec, my) {
      var that, 其他的私有实例变量;
      my = my || {};
      把共享的变量和函数添加到my中;
      that = 一个新对象;
      return that;
  };

  spec: 包括构造器需要构造一个新实例的所有信息
  my：一个为继承链中的构造器提供秘密共享的容器

  - 给my对象添加共享的秘密成员:
    my.member = value;

  - 函数化模式有很大的灵活性，相比伪类模式带来的工作更少，还得到了更好的封装和信息隐藏，以及访问父类方法的能力