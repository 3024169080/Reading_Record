# Vue 学习  

## day 1  

比较了 Vue 中 MVVM 思想和后端的 MVC 思想  
学习了 Vue 中 MVVM 思想  
学习了数据绑定和事件绑定  

## day 2  

更改了一下学习策略，直接通过 vue-cli 脚手架学习 Vue，同时也会根据学习的内容使用不同的方式进行学习  

- 事件修饰符 --- Demo1.vue  
  1. .stop --- 阻止事件冒泡 --- 在子元素身上进行处理阻止事件冒泡  
  2. .prevent --- 阻止默认事件
  3. .self --- 只有点击元素自身的时候才会触发事件 --- 在父元素上进行处理阻止事件冒泡  
  4. .capture --- 添加事件侦听器时使用事件捕获机制 --- 从外到里执行事件  
  5. .once --- 事件只触发一次  

- .stop 和 .self 阻止冒泡的区别：  
  .self 只会阻止自己的冒泡  

- v-model 数据的双向绑定 --- Demo2.vue  
  v-model 实现计算器  

## day 3  

品牌列表综合案例，综合运用数据、事件绑定，事件修饰符等  
学习了过滤器 filter --- 私有过滤器会屏蔽全局同名过滤器  
通过过滤器实现品牌列表综合案例中时间的格式化  

## day4  

- 完善品牌列表案例，添加 padstart 填充时间格式  

- 学习了自定义全局按键修饰符，并把它添加到案例中  
  Vue.config.keyCodes.f2 = 113;  

- 学习自定义指令(全局和局部两种方式)，添加到案例中实现文本框获得焦点  
  全局：Vue.directive  
  局部/私有：directives  

- 简单了解自定义指令中第二个参数提供的几个钩子函数：  
  通过 binding 拿到传递的参数  
  1. bind：指令第一次绑定到元素上的时候调用 --- 只调用一次 --- 元素刚绑定指令的时候还没有插入 DOM 中  
  2. inserted：被绑定元素插入父节点时调用  
  3. update：所在组件的 VNode 更新时调用  
  4. componentUpdated：所在组件的 VNode 及其孩子的 VNode 全部更新时调用  
  5. unbind：指令与元素解绑的时候调用 --- 只调用一次  
  - 第一个参数都是 el，表示绑定的元素  
  - 和 JS 行为有关的操作，最好在 inserted 中执行，防止 JS 行为不生效  
  - 和样式相关的操作，一般都可以在 bind 中执行  

## day 5

- 学习自定义指令集成第三方插件 --- 当成第三方插件引入  

- 生命周期钩子函数学习 --- 三大类  
  1. 创建期间的生命周期函数  
     + beforeCreate：实例刚在内存中被创建，此时还没有初始化好 data 和 methods    
     + created：实例已经在内存创建，data 和 methods 已经创建，还没有开始编译模板  
     + beforeMount：已经完成模板的编译，但是还没有挂载到页面中，只是在内存中渲染好了模板，只有模板字符串  
     + mounted：此时已经将编译好模板挂载到页面指定的容器中显示  
  2. 运行期间的生命周期函数  
     + beforeUpdate：状态更新之前执行，此时 data 中的状态值是最新的，但是页面上数据还是旧的，因为还没有重新开始渲染 DOM  
     + updated：实例更新完成后调用，此时 data 中的状态值和界面上显示的数据都完成了更新，界面已经被重新渲染好了  
  3. 销毁期间的生命周期函数   
     + beforeDestroy：实例销毁之前调用，此时实例仍然完全可用  
     + destroyed：Vue实例销毁后调用，调用后 VUe 实例指示的所有东西都会解绑，所有的事件监听器都会被移除，所有的子实例也会被销毁  
  - 如果要调用 methods 中的方法，或者操作 data 中的数据，最早只能在 created 中  
  - 使用 vue-cli 脚手架，生命周期表现形式可能会有不一样，分成了多个模板  
(改到 vue/lifecycle.html)  
  - mounted 是实例创建期间的最后一个生命周期函数，当执行完 mounted，实例已经被完全创建了，组件进入运行阶段   
  - 如果要通过某些插件操作页面上的 DOM 结点，最早要在 mounted 中进行  

- 计算属性和侦听属性 --- computed & watch  
  1. computed 计算属性： 
     + 表达式太复杂的话会导致模板难以维护，而且如果多个地方使用该表达式的话会导致重复，可以使用 computed 计算属性进行优化  
     + computed 数据的使用和 data 中的数据使用方法一样，只不过 computed 中的数据是一个函数，返回计算结果  
     + 使用函数也可以达到 computed 属性的效果，但是不推荐使用  
       原因：使用函数计算，当有数据更新，不管是不是要计算的数据，计算函数都会被执行一次，如果使用 computed，如果要计算的数据没有改变，改变的是其他的数据，就不会执行 computed，直接使用之前的数据，效率和性能更好  
     + 使用场景：  
       某个数据受多个数据影响，或者需要对其他数据进行 js 处理再显示  
  2. watch 监听属性：  
     + 默认是不会立即执行，如果要立即执行需要写成对象的格式(当 data 中的数据给的是空的时候或者是需要一开始给一个默认值的时候)
     ```js
     watch: {
      language: {
        handler(newVal) {
          if (newVal === "ch") {
            this.zhangsan = "张三";
            this.lisi = "李四";
          } else if ((newVal = "en")) {
            this.zhangsan = "zhangsan";
            this.lisi = "lisi";
          }
        },
        immediate: true
      }
    },
     ```
     + 使用场景：  
       一个数据的变化会影响多个数据，或者一个数据的变化的时候需要执行异步操作  